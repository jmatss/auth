
import { ListView, Palette } from "std-widgets.slint";

/// The direction in which a code should be moved in the list of codes.
export enum MoveDirection {
  Up,
  Down,
}

export struct Code {
  unique_idx: int,
  name: string,
  issuer: string,
  /// Valid code for the current time step.
  code: string,
  /// Code for the next valid time step.
  next_code: string,
  /// The exact time a Code is valid (usually 30 sec).
  step: duration,
  /// The "unix time" when this code struct was created.
  start_unix_time: duration,
  /// The "unix time" when this code gets invalid. Used for time keeping in rust.
  valid_until_unix_time: duration,
}

export component CodesPage inherits ListView {
  in property <[Code]> codes;
  callback navigate_to_edit_code_page(Code);

  mouse-drag-pan-enabled: true;
  horizontal-scrollbar-policy: ScrollBarPolicy.always-off;

  for item in codes : VerticalLayout {
    property <Code> local_item: item;
    changed local_item => {
      // Hack to reset timer when new item is set. Unable to do with normal binding.
      nameCode.show_next_code = false;
      timer.running_duration = 0;
      timer.running = true;
      timer.start_unix_time = item.start_unix_time;
      timer.valid_until_unix_time = item.valid-until-unix-time;
    }

    padding-top: 0.5rem;

    timer := Timer {
      property <duration> running_duration;
      property <duration> start_unix_time: item.start_unix_time;
      property <duration> valid_until_unix_time: item.valid_until_unix_time;

      interval: 100ms;

      triggered => {
        self.running_duration += timer.interval;
        if (self.running_duration + self.start_unix_time >= self.valid_until_unix_time) {
          // The code is now invalid. We will just wait and assume that the backend will
          // replace this `item` with a new one.
          self.running = false;
        }
      }
    }

    Rectangle {
      background: Palette.alternate-background;

      VerticalLayout {
        HorizontalLayout {
          padding-left: 1rem;
          padding-right: 1rem;

          Rectangle {
            horizontal-stretch: 1;

            Rectangle {
              height: nameText.height;
              y: parent.height / 2 - nameText.height / 2;

              nameText := Text {
                x: 0;
                font-size: 1.5rem;
                text: item.issuer.is-empty ? item.name : (item.name + " (" + item.issuer + ")");
                wrap: char-wrap;
              }
            }

            TouchArea {
              clicked => root.navigate_to_edit_code_page(item);
            }
          }

          VerticalLayout {
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;

            Rectangle {
              height: nameCode.height;
              background: Palette.alternate-background;

              TouchArea {
                clicked => {
                  nameCode.show_next_code = !nameCode.show_next_code;
                };
              }

              nameCode := Text {
                property <bool> show_next_code: false;

                text: self.show_next_code ? item.next-code : item.code;
                color: self.show_next_code ? #780606 : Palette.selection-background;
                font-size: 4rem;
              }
            }
          }
        }
      }
    }

    countDown := Rectangle { 
      height: 0.5rem;
      background: Palette.selection-background;

      Rectangle {
        background: #780606;
        width: parent.width * ((item.step - (timer.valid_until_unix_time - timer.start_unix_time) + timer.running_duration) / item.step);
        x: 0;
      }
    }
  }
}